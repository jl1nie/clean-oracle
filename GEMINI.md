# GEMINI.md

## プロジェクト概要「***Clean Oracle***」
### 目的
 部屋のきれいさを判定するWebアプリケーションを作成する
### 機能
1. きれいさの基準となる「神の部屋」を事前に登録する
2. 神の部屋と同一位置・同一画角の「民の部屋」をアップロードする
3. 「神の部屋」との現在の「民の部屋」の画像を比較してきれいさの判定を行い神託として表示する。
　　　
## 主要な技術スタック

- 言語: Python
- パッケージ管理: uv (pipの使用は厳禁。すべてuvから起動)
- フォーマッター/リンター: ruff
- 型チェック: mypy
- フロントエンド: Vite (React)、Express
- バックエンド: Flask, requests (LLM連携用), gunicorn (WSGIサーバー)
- コンテナ： Docker (ファイルの永続化はローカルマウント)
- ローカルLLM: LMStudio (APIのURLはコンテナの環境変数で指定し、REST APIで呼び出す)
- 使用するLLM: gemma-3-27b

## システム構成
 - dockerコンテナ上にサービスとして「フロントエンド」、「バックエンド」を置く
 - フロントエンドではReactを使ってUIを構成し、神の部屋の登録、民の部屋のアップロード、判定結果の表示などを行う
 - バックエンドでは、神の部屋の保存(ローカルマウントでファイルに保存)、神の部屋、民の部屋比較、神託生成のためのLLM呼び出しを行う

## 各サーバーの機能
### フロントエンド
 - 参照画面が登録されていない場合は、登録画面を表示。バックエンドで画像登録。画像のUUIDが返るのでブラウザに保存後、アップロード画面に遷移
 - アップロード画面では「神託を授けます」のメッセージと「アップロード」ボタンがあり「民の部屋」をアップロード
 - 「民の部屋」がアップロードされると「神の部屋」のUUID、設定情報と共にバックエンドに送り、スピナーを表示。
 - 指定したUUIDの「神の部屋」がない場合はエラーが戻るので、再度神の部屋の登録から始める。
 - ��民の部屋」の分析結果が神託と共に戻るので、画像と神託を表示、「再度トライ」で「アップロード画面」
 - すべてのページには設定ボタンがあり、設定ダイアログでは「神を選ぶ」で「Male」「Female」を選び設定情報で送る。

### バックエンドの機能
 - 参照画像となる「神の部屋」の登録を行う。アップロードされたjpg画像をファイルとして保存し対応するUUIDのファイル名で保存、UUIDを返す。
 - 比較画像となる「民の部屋」と「神の部屋」を比較し神託をだす。参照画像となる「神の部屋」のアップロードされたUUIDから「神の部屋」の画像を特定し、「神の部屋」「民の部屋」の二つをLLMにプロンプト共に渡す。
 - LLMから得られたレスポンスをフロントエンドに返す。
  
### バックエンドのAPI
|エンドポイント| メソッド| 機能 | パラメータ | レスポンス |
|:--|:--:|:--|:--|:--|
|/api/register|POST| 「神の部屋」の登録| image: 「神の部屋」(jpg) | uuid: 「神の部屋」の画像ファイ��を表すUUID|
|/api/oracle| POST | 「民の部屋」への神託| reference_uuid  : 「神の部屋」のUUID<br> image : 「民の部屋」(jpg)<br> config : 設定情報　type : "Male", "Female"|　　　　　　message : 神託(HTML text)<br>|
|/api/image/<uuid>| GET | 画像ファイルの取得 | uuid: 画像ファイルのUUID | image: 画像ファイル |

### Vision LLMによる画像分析プロンプト
- 与えられた「参照画像」と「現状画像」を比較し、以下の項目について分析結果をJSON形式で返す。
- JSON形式の例:
```json
{
  "床": {"散らかり": "服や鞄が放置されている", "点数": 5},
  "机": {"散らかり": "本が散乱している", "点数": 10},
  "ベッド": {"散らかり": "布団がぐちゃぐちゃ", "点数": 15}
}
```
- 分析項目:
    1. 「床」に、服や鞄がゴミが放置されていないか
    2. 「机」の上に、服が放置されていない、かばんや本が整理されておかれているか
    3. 「ベッド」の上に、かばんや本がおかれていないか、「ベッド」の上の布団が整理されているか

### きれいさ判定プロンプト
- 与えられた「神の部��」と「民の部屋」の画像をVision LLMに渡し、比較して「民の部屋」のきれいさを0点から100点で判定(point: int)し、整理整頓のための神託(oracle:html text)を返す
- 「民の部屋」は「神の部屋」と同一位置・同一画角で撮影されている
- きれいさの判定方法
    1. 「神の部屋」から「ベッド」「机」「床」を判別し、「民の部屋」でその場所を特定する
    1. 「民の部屋」から以下を判定する
        1. 「床」に、服や鞄がゴミが放置されていない
        1. 「机」の上に、服が放置されていない、かばんや本が整理されておかれている
        1. 「ベッド」の上に、かばんや本がおかれていない、「ベッド」の上の布団が整理されている

    1. 上記をすべて満たした場合を100点とする。配点は「床」50点、「ベッド」30点、「机」:20点として、各パートの判定基準に採点する

    1. 結果はHTML形式とし、神託のみとする。マークダウンのタグ（```htmlなど）や、余分な返答や解説は一切入れ���いこと
    1. 神託は整理整頓を促す点数を含むシンプルかつ厳かな一文とし、ヘッダー等は設けない。その後「床」「ベッド」「机」の各々の整理すべきポイントをシンプルかづ厳かな一文で生成する。
  
## ディレクトリ構成
```
./
├─ GEMINI.md         # このファイル
├─ frontend/         # Vite + React + Express (静的ファイル+UI用API)
├─ backend/          # Flask APIサーバー
├─ shared/           # 型定義 / JSON Schema / 設定 / ユーティリティ共有
├─ .env              # APIキーやモデルエンドポイントなど
└─ docker-compose.yml
```
## セットアップと依存関係のインストール

`uv` を使って仮想環境を作成し、依存関係をインストールします。`pip` の使用は禁止されています。

```bash
# 仮想環境の作成と有効化
uv venv
source .venv/bin/activate

# 依存関係のインストール (requirements.txt がある場合)
uv pip install -r requirements.txt
```

**Dockerコンテナの依存関係:**
`backend/requirements.txt`には、`Flask`、`flask-cors`、`gunicorn`、`requests`、`pytest`が含まれています。これらの依存関係はDockerイメージビルド時に自動的にインストールされます。

**`backend/app.py`の`IMAGE_DIR`パス修正:**
`backend/app.py`内の`IMAGE_DIR`のパスは、ホストマシンでのテスト実行時に正しく動作するよう、相対パスに修正されました。
`IMAGE_DIR = os.path.join(os.path.dirname(__file__), "..", "images")`
これにより、コンテナ環境とホスト環境の両方で画像ディレクトリが正しく参照されます。

## ビルド & 実行コマンド

プロジェクトをビルドし、ローカルで実行するには、以下のコマンドを使用します。

```bash
docker compose up --build
```

**環境設定:**
フロントエンドとバックエンド間の通信を正しく設定するために、プロジェクトルートの`.env`ファイルに以下の変数を設定します。

```
# バックエンドAPIのベースURL
VITE_API_BASE_URL=http://localhost:5000 

# ローカルLLMのAPIエンドポイント
LLM_API_URL=http://localhost:1234/v1/chat/completions
```

**ネットワーク設定の注意点:**
`backend`サービスは`docker-compose.yml`で`network_mode: "host"`を使用しています。これにより、`backend`コンテナはホストマシンのネットワーク名前空間を共有し、ホストの`localhost`経由でLMStudioなどのホストサービスに直接アクセスできます。この設定のため、`backend`サービスには`ports`マッピングは不要です。

**開発時のホットリロード:**
`docker-compose.yml`では、`frontend`および`backend`ディレクトリがコンテナ内にマウントされています。これにより、ローカルでコードを修正すると、自動的にコンテナ内のアプリケーションに反映（ホットリロード）され、開発効率が向上します。

**ファイル権限の設定:**
バックエンドが画像を保存する`/images`ディレクトリは、ホストマシンの`./images`ディレクトリにマウントされます。コンテナ内のアプリケーションユーザーがこのディレクトリに書き込めるよう、ホストマシン上で適切な権限を設定する必要があります。例えば、コンテナ内の`appuser`のUIDが`100`の場合、以下のコマンドで権限を付与できます。

```bash
sudo chown 100:100 /home/minoru/src/clean-oracle/images
```

**フロントエンドのAPI呼び出し:**
フロントエンド（Reactアプリケーション）は、Viteのプロキシ設定を利用してバックエンドAPIを呼び出します。コンポーネント内の`fetch`リクエストでは、`/api/register`のような相対パスを使用してください。これにより、開発サーバーがリクエストを適切にバックエンド（またはE2Eテスト時のモックサーバー）に転送します。

## テストコマンド

### バックエンド

バックエンドのテストは`pytest`を使用して実行します。`backend`ディレクトリに移動し、以下のコマンドを実行してください。

```bash
cd backend
uv venv
. .venv/bin/activate
uv pip install -r requirements.txt
.venv/bin/pytest
```

### フロントエンド

フロントエンドのユニットテストは`vitest`、E2Eテストは`playwright`を使用して実行します。

`frontend`ディレクトリに移動し、以下のコマンドを実行してください。

```bash
cd frontend
npm install
```

**ユニットテスト:**
```bash
npm test
```

**E2Eテスト:**
```bash
npm run test:e2e
```

**E2Eテストの注意点:**
- **APIモッキング:** E2Eテストでは、Viteのプロキシ機能や外部のモックサーバーに依存せず、Playwrightの`page.route()`機能を使用してAPIリクエストを直接モックしています。これにより、テストの安定性と信頼性を高めています。テストコード(`frontend/tests/oracle.spec.js`)内で、`/api/register`と`/api/oracle`へのレスポンスが定義されています。
- **テストサーバーの起動:** E2Eテストは、`playwright.config.js`の`webServer`設定に基づき、テスト実行前に自動的にVite開発サーバー(`npm run test:serve`経由)を起動します。
- **BOM(Byte Order Mark)の問題:** 過去に、テストファイルにBOMが混入したことで、文字列ベースのアサーションが失敗する問題が発生しました。この問題は、ファイルをBOMなしのUTF-8形式で保存し直すことで解決しました。同様の問題が発生した場合は、ファイルのエンコーディングを確認してください。
- **依存関係のインストール:** 初回実行時やブラウザのバージョンアップ後など、Playwrightが必要とするブラウザの依存関係が不足している場合があります。その場合は、以下のコマンドを実行して依存関係��インストールしてください（`sudo`権限が必要です）。
  ```bash
  sudo npx playwright install-deps
  ```

## リンター & フォーマッター

コードのフォーマットと静的解析には `ruff` を使用します。
bash
# フォーマット
ruff format .

# lintチェックと自動修正
ruff check . --fix
```

## 型チェック

型チェックには `mypy` を使用します。

```bash
mypy .
```
